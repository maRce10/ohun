#' @title Acoustic template detection from time-frequency cross-correlations
#'
#' @description \code{template_detector} find signal occurrences in cross-correlation vectors from \code{\link{template_correlator}}
#' @usage template_detector(template.correlations, parallel = 1, threshold, pb = TRUE,
#'  verbose = TRUE)
#' @param template.correlations object of class 'template_correlations' generated by \code{\link{template_correlator}} containing the correlation score vectors.
#' @param parallel Numeric. Controls whether parallel computing is applied.
#' It specifies the number of cores to be used. Default is 1 (i.e. no parallel computing).
#' @param threshold Numeric vector of length 1 with a value between 0 and 1 specifying the correlation threshold for detecting signal occurrences (i.e. correlation peaks). Must be supplied. Correlation scores are forced to between 0 and 1 (by converting negative scores to 0). 0 and 1 represent the lowest and highest similarity to the template respectively.
#' @param pb Logical argument to control progress bar. Default is \code{TRUE}.
#' @param verbose Logical argument to control if some summary messages are printed to the console.
#' @return The function returns a data frame with the start and end and correlation score for the
#' detected signals.
#' @export
#' @name template_detector
#' @details This function infers signals occurrences from cross-correlation scores along sound files. Correlation scores must be generated first using \code{\link{template_correlator}}. The output contains the start and end of the detected signals as well as the cross-correlation score ('scores' column) for each detection.
#' @examples
#' {
#' # load example data
#' data(list = c("Phae.long1", "Phae.long2", "Phae.long3"))
#'
#' # save sound files
#' writeWave(Phae.long1, file.path(tempdir(), "Phae.long1.wav"))
#' writeWave(Phae.long2, file.path(tempdir(), "Phae.long2.wav"))
#' writeWave(Phae.long3, file.path(tempdir(), "Phae.long3.wav"))
#'
#' # template for the first sound file in 'lbh_selec_reference'
#' templ1 <- lbh_selec_reference[1, ]
#'
#' # generate template correlations
#' tc <- template_correlator(templates = templ1, path = tempdir(), files = "Phae.long1.wav")
#'
#' # template detection
#' td <- template_detector(template.correlations = tc, threshold = 0.4)
#'
#' # diagnose detection
#' diagnose_detection(reference =
#' lbh_selec_reference[lbh_selec_reference$sound.files == "Phae.long1.wav", ],
#' detection = td)
#'
#' # template for the second and third sound file in 'lbh_selec_reference'
#' # which have similar song types
#' templ2 <- lbh_selec_reference[4, ]
#'
#' # generate template correlations
#' tc <- template_correlator(templates = templ2, path = tempdir(),
#' files = c("Phae.long1.wav", "Phae.long2.wav"))
#'
#' # template detection
#' td <- template_detector(template.correlations = tc, threshold = 0.3)
#'
#' # diagnose detection
#' diagnose_detection(reference =
#' lbh_selec_reference[lbh_selec_reference$sound.files %in% c("Phae.long3.wav",
#' "Phae.long2.wav"), ],
#' detection = td)
#' }
#' @seealso \code{\link{energy_detector}}, \code{\link{template_correlator}}, \code{\link{optimize_template_detector}}
#' @author Marcelo Araya-Salas \email{marcelo.araya@@ucr.ac.cr})
#'
#' @references {
#' Araya-Salas, M. (2021), ohun: automatic detection of acoustic signals. R package version 0.1.0.
#' }
# last modification on jan-03-2020 (MAS)
template_detector <- function(template.correlations, parallel = 1, threshold, pb = TRUE, verbose = TRUE)
{
  # check xc.output being a autodetec.output object
  if (!(is(template.correlations, "template_correlations")))
    stop("'template.correlations' must be and object of class 'template_correlations'")

  #if threshold is not vector or length!=1 stop
  if (!is.numeric(threshold))
    stop("'threshold' must be a numeric vector of length 1")
  if (!is.vector(threshold))
    stop("'threshold' must be a numeric vector of length 1")
  if (!length(threshold) == 1)
    stop("'threshold' must be a numeric vector of length 1")
  if(threshold >= 1 | threshold <= 0)
    stop("'threshold' must be a number between 0 and 1")

  # set clusters for windows OS or more decent OSs
  if (Sys.info()[1] == "Windows" & parallel > 1)
    cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel

  # loop over scores of each dyad
    sel_table_list <- warbleR:::pblapply_wrblr_int(pbar = pb, X = 1:(length(template.correlations) - 1), cl = cl, FUN = function(i){

      # extract data for a dyad
      temp_cor <- template.correlations[[i]]

      ## get peaks as the ones higher than previous and following scores
      peak_position <- which(c(FALSE, diff(temp_cor$correlation.scores) > 0) & c(rev(diff(rev(temp_cor$correlation.scores)) > 0), FALSE) & temp_cor$correlation.scores > threshold)

      # get peaks and their scores
      scores <- temp_cor$correlation.scores[peak_position]
      peak_time <- seq(0, temp_cor$file.duration, length.out = length(temp_cor$correlation.scores))[peak_position]

      # get file and template names
      file_template <- strsplit(names(template.correlations)[i], "/")[[1]]

      # calculate starts as the peak location minus half the template duration
      starts <- if (length(peak_time) > 0) peak_time - (temp_cor$template.duration / 2) else NA
      # cannot be negative
      starts[starts < 0] <- 0

      # calculate starts as the peak location minus half the template duration
      ends <- if (length(peak_time) > 0) peak_time + (temp_cor$template.duration / 2) else NA

      # cannot be higher than file duration
      ends[ends > temp_cor$file.duration] <- temp_cor$file.duration

      # put results in an extended selection table
      sel_table <- data.frame(sound.files = file_template[2], selec = if (length(scores) > 0) seq_len(length(scores)) else 1, start = starts, end = ends, template = file_template[1], scores = if (length(scores) > 0) scores else NA)

      return(sel_table)
  })

  # put results in a data frame
  sel_table_df <- do.call(rbind, sel_table_list)

  # relabel rows
  rownames(sel_table_df) <- 1:nrow(sel_table_df)

  # no detections
  if (all(is.na(sel_table_df$start)) & verbose)
  write(file = "", x = "no signals above threshold were detected")

  return(sel_table_df)
}
