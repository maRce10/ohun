proportional.duration.true.positives = NA,
sensitivity = 0,
specificity =  0,
stringsAsFactors = FALSE
)
# add duty cycle
if (!is.null(path) & time.diagnostics)
no_detec$duty.cycle <- 0
performance_list[[length(performance_list) + 1]] <- no_detec
}
# put in a single data frame
performance_df <- do.call(rbind, performance_list)
performance_df
path
time.diagnostics
time.diagnostics = TRUE
# make it a data frame if selection table
if (warbleR::is_selection_table(detection))
detection <- as.data.frame(detection)
# make it a data frame if selection table
if (warbleR::is_selection_table(reference))
reference <- as.data.frame(reference)
# remove rows with no info
detection <- detection[!is.na(detection$start), ]
if (nrow(detection) > 0)
{
# double checking happens inside label_detection()
labeled_detection <- label_detection(reference = reference, detection = detection, parallel = parallel, pb = pb)
# # add row labels to reference for getting false negatives
reference$..row.id <- 1:nrow(reference)
# duration of corresponding selection in reference
labeled_detection$reference.duration <- sapply(1:nrow(labeled_detection), function(x){
if (is.na(labeled_detection$reference.row[x])) NA  else
if (grepl("-", labeled_detection$reference.row[x]))  NA else
reference$end[as.numeric(labeled_detection$reference.row[x])] - reference$start[as.numeric(labeled_detection$reference.row[x])]
})
# look at detections matching 1 training selection at the time
performance_list <- lapply(unique(labeled_detection$sound.files), function(z){
# get subset for that sound file
sub_detec <- labeled_detection[labeled_detection$sound.files == z, ]
sub_ref <- reference[reference$sound.files == z, ]
# get row index in reference for detected signals
detected_reference_rows <- unique(na.omit(unlist(lapply(sub_detec$reference.row, function(x) unlist(strsplit(as.character(x), "-"))))))
performance <- data.frame(
sound.files = z,
true.positives = length(detected_reference_rows),
false.positives = sum(grepl("false", sub_detec$detection.class)),
false.negatives = sum(!sub_ref$..row.id %in% detected_reference_rows),
split.positives = length(unique(
unlist(lapply(sub_detec$reference.row[grepl("split)", sub_detec$detection.class)], function(x) unlist(strsplit(x, "-")))))),
merged.positives = sum(grepl("merge", sub_detec$detection.class)),
mean.duration.true.positives = mean((sub_detec$end - sub_detec$start)[grep("true", sub_detec$detection.class)]),
mean.duration.false.positives = mean((sub_detec$end - sub_detec$start)[grep("false", sub_detec$detection.class)]),
mean.duration.false.negatives = mean((sub_ref$end - sub_ref$start)[!sub_ref$..row.id %in% detected_reference_rows]),
overlap.to.true.positives = if(any(!is.na(sub_detec$overlap))) mean(sub_detec$overlap, na.rm = TRUE) else NA,
proportional.duration.true.positives = mean(sub_detec$reference.duration, na.rm = TRUE) / mean((sub_ref$end - sub_ref$start)[sub_ref$..row.id %in% detected_reference_rows], na.rm = TRUE),
stringsAsFactors = FALSE
)
# add duty cycle
if (!is.null(path) & time.diagnostics){
# get file durations
performance$duty.cycle <- sum((sub_detec$end - sub_detec$start), na.rm = TRUE) / warbleR::duration_sound_files(files = z, path = path)$duration
}
# add sensitivity and specificity
performance$sensitivity <- length(detected_reference_rows) / nrow(sub_ref)
performance$specificity <-  if (nrow(sub_detec) > 0 & length(detected_reference_rows) > 0) length(detected_reference_rows) / (nrow(sub_ref) + sum(grep("false", sub_detec$detection.class))) else 0
# replace NaNs with NA
for(i in 1:ncol(performance))
if (is.nan(performance[, i])) performance[, i] <- NA
# fix values when no false positives or true positives
performance$false.positives[performance$false.positives < 0] <- 0
performance$mean.duration.false.positives[is.na(performance$mean.duration.false.positives) | performance$false.positives == 0] <- NA
performance$mean.duration.true.positives[is.na(performance$mean.duration.true.positives) | performance$true.positives == 0] <- NA
# make sensitvities higher than 1 (because of split positives) 1
performance$sensitivity[performance$sensitivity > 1] <- 1
return(performance)
})
# add diagnostics of files in reference but not in detection
if (any(!reference$sound.files %in% unique(labeled_detection$sound.files))){
no_detec <- data.frame(
sound.files = setdiff(reference$sound.files, unique(labeled_detection$sound.files)),
true.positives = 0,
false.positives = 0,
false.negatives = sapply(setdiff(reference$sound.files, unique(labeled_detection$sound.files)), function(x) sum(reference$sound.files == x)),
split.positives = NA,
merged.positives = NA,
mean.duration.true.positives = NA,
mean.duration.false.positives = NA,
mean.duration.false.negatives = sapply(setdiff(reference$sound.files, unique(labeled_detection$sound.files)), function(x) mean((reference$end - reference$start)[reference$sound.files == x])),
overlap.to.true.positives = NA,
proportional.duration.true.positives = NA,
sensitivity = 0,
specificity =  0,
stringsAsFactors = FALSE
)
# add duty cycle
if (!is.null(path) & time.diagnostics)
no_detec$duty.cycle <- 0
performance_list[[length(performance_list) + 1]] <- no_detec
}
# put in a single data frame
performance_df <- do.call(rbind, performance_list)
} else  {
performance_df <- data.frame(
sound.files = unique(reference$sound.files),
true.positives = 0,
false.positives = 0,
false.negatives = sapply(unique(reference$sound.files), function(x) sum(reference$sound.files == x)),
split.positives = NA,
merged.positives = NA,
mean.duration.true.positives = NA,
mean.duration.false.positives = NA,
mean.duration.false.negatives = sapply(unique(reference$sound.files), function(x) mean(reference$end - reference$start)),
overlap.to.true.positives = NA,
proportional.duration.true.positives = NA,
sensitivity = 0,
specificity =  0,
stringsAsFactors = FALSE
)
# add duty cycle
if (!is.null(path) & time.diagnostics)
performance_df$duty.cycle <- 0
}
performance_df
summarize_diagnostic(diagnostic = performance_df, time.diagnostics = time.diagnostics)
names(performance_df)
performance_df[ , match(c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"), names(performance_df))]
performance_df[ , match(c( "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity", "sound.files"), names(performance_df))]
performance_df
# sort columns
performance_df <- performance_df[ , match(c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"), names(performance_df))]
summarize_diagnostic(diagnostic = performance_df, time.diagnostics = time.diagnostics)
diagnostic = performance_df
time.diagnostics
# basic columns required in 'diagnostic'
basic_colms <- c("true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "overlap.to.true.positives", "sensitivity", "specificity")
#check diagnostic
if (any(!(basic_colms %in% colnames(diagnostic))))
stop(paste(paste(
basic_colms[!(basic_colms %in% colnames(diagnostic))], collapse =
", "
), "column(s) not found in 'diagnostics'"))
# get extra column names (ideally should include tuning parameters)
extra_colms <- setdiff(colnames(diagnostic), c(basic_colms, c("sound.files", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "proportional.duration.true.positives")))
source("~/Dropbox/R_package_testing/ohun/R/summarize_diagnostic.R")
# performance_df <-
summarize_diagnostic(diagnostic = performance_df, time.diagnostics = time.diagnostics)
names(diagnostic)
any(names(diagnostic) == "duty.cycle")
source("~/Dropbox/R_package_testing/ohun/R/summarize_diagnostic.R")
# performance_df <-
summarize_diagnostic(diagnostic = performance_df, time.diagnostics = time.diagnostics)
source("~/Dropbox/R_package_testing/ohun/R/summarize_diagnostic.R")
# using smoothing and minimum duration
optimize_energy_detector(reference = lbh_reference, path = tempdir(), threshold = c(0.06, 0.4), hop.size = 6.8, peak.amplitude = 40,
bp = c(2, 9), min.duration = c(0.09, 0.1), by.sound.file = FALSE)
ed <- energy_detector(path = tempdir(), threshold = 0.06, hop.size = 6.8, peak.amplitude = 40, bp = c(2, 9), min.duration = 0.09)
diagnose_detection(reference = lbh_reference, detection = ed, path = tempdir(), by.sound.file = FALSE, time.diagnostics = TRUE)
label_spectro(wave = lbh_1, envelope = TRUE, threshold = 50, detection = ed)
lbh_1
data("lbh_reference", "lbh_1")
label_spectro(wave = lbh_1, envelope = TRUE, threshold = 50, detection = ed)
data("lbh_reference", "lbh1")
label_spectro(wave = lbh1, envelope = TRUE, threshold = 50, detection = ed)
label_spectro(wave = lbh1, envelope = TRUE, threshold = 0.06, detection = ed)
ed <- energy_detector(path = tempdir(), threshold = 0.2, hop.size = 6.8, peak.amplitude = 40, bp = c(2, 9), min.duration = 0.09)
diagnose_detection(reference = lbh_reference, detection = ed, path = tempdir(), by.sound.file = FALSE, time.diagnostics = TRUE)
label_spectro(wave = lbh1, envelope = TRUE, threshold = 0.2, detection = ed)
# using smoothing and minimum duration
optimize_energy_detector(reference = lbh_reference, path = tempdir(), threshold = c(6, 20), hop.size = 6.8, peak.amplitude = 40,
bp = c(2, 9), min.duration = c(0.09, 0.1), by.sound.file = FALSE)
ed <- energy_detector(path = tempdir(), threshold = 20, hop.size = 6.8, peak.amplitude = 40, bp = c(2, 9), min.duration = 0.09)
source("~/Dropbox/R_package_testing/warbleR/warbleR/R/sound_pressure_level.R")
source("~/Dropbox/R_package_testing/ohun/R/energy_detector.R")
ed <- energy_detector(path = tempdir(), threshold = 20, hop.size = 6.8, peak.amplitude = 40, bp = c(2, 9), min.duration = 0.09)
source("~/Dropbox/R_package_testing/warbleR/warbleR/R/pblapply_wrblr_int.R")
ed <- energy_detector(path = tempdir(), threshold = 20, hop.size = 6.8, peak.amplitude = 40, bp = c(2, 9), min.duration = 0.09)
diagnose_detection(reference = lbh_reference, detection = ed, path = tempdir(), by.sound.file = FALSE, time.diagnostics = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
data("lbh_reference")
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference)
# missing one in detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference[-1, ])
# an extra one in detection
diagnose_detection(reference = lbh_reference[-1, ], detection = lbh_reference)
# with time diagnostics
diagnose_detection(reference = lbh_reference[-1, ],
detection = lbh_reference, time.diagnostics = TRUE)
# and extra sound file in reference
diagnose_detection(reference = lbh_reference,
detection =
lbh_reference[lbh_reference$sound.files != "lbh1", ])
# and extra sound file in detection
diagnose_detection(reference =
lbh_reference[lbh_reference$sound.files != "lbh1", ],
detection = lbh_reference)
# and extra sound file in detection by sound file
dd <- diagnose_detection(reference =
lbh_reference[lbh_reference$sound.files != "lbh1", ],
detection = lbh_reference, time.diagnostics = TRUE, by.sound.file = TRUE)
# get summary
summarize_diagnostic(dd)
remove.packages("warbleR")
remotes::install_github("maRce10/warbleR")
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
match(c(1, 2, 3), c(3, 2, 1))
match(c(1, 2, 3), c(3, 1))
match(c(1, 3), c(3, 2, 1))
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
#'  \item \code{specificity}: Proportion of detections that correspond to signals in 'reference' that were detected. In a perfect detection routine it should be 1.
#'  }
#' @export
#' @name diagnose_detection
#' @details The function evaluates the performance of a signal detection procedure by comparing its output selection table to a reference selection table in which all signals of interest have been selected.
#' @examples {
#' # load data
#' data("lbh_reference")
#'
#' # perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference)
# missing one in detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference[-1, ])
# an extra one in detection
diagnose_detection(reference = lbh_reference[-1, ], detection = lbh_reference)
# with time diagnostics
diagnose_detection(reference = lbh_reference[-1, ],
detection = lbh_reference, time.diagnostics = TRUE)
# and extra sound file in reference
diagnose_detection(reference = lbh_reference,
detection =
lbh_reference[lbh_reference$sound.files != "lbh1", ])
# and extra sound file in detection
diagnose_detection(reference =
lbh_reference[lbh_reference$sound.files != "lbh1", ],
detection = lbh_reference)
# and extra sound file in detection by sound file
dd <- diagnose_detection(reference =
lbh_reference[lbh_reference$sound.files != "lbh1", ],
detection = lbh_reference, time.diagnostics = TRUE, by.sound.file = TRUE)
# get summary
summarize_diagnostic(dd)
#' }
#' @seealso \code{\link{optimize_energy_detector}}, \code{\link{optimize_template_detector}}
#' @author Marcelo Araya-Salas \email{marcelo.araya@@ucr.ac.cr})
#'
#' @references {
#' Araya-Salas, M. (2021), ohun: automatic detection of acoustic signals. R package version 0.1.0.
#' }
# last modification on sept-2021 (MAS)
diagnose_detection <- function(reference, detection, by.sound.file = FALSE, time.diagnostics = FALSE, parallel = 1, pb = TRUE, path = NULL)
diagnose_detection(reference = lbh_reference, detection = lbh_reference)
diagnose_detection(reference = lbh_reference, detection = lbh_reference[-1, ])
diagnose_detection(reference = lbh_reference, detection = lbh_reference[-1, ])
performance_df
match(names(performance_df), c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"))
performance_df$duty.cycle <- NULL
match(names(performance_df), c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"))
FUN <- "diagnose_detection"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
data("lbh_reference")
# save wav file examples
write.sound.files()
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE)
reference = lbh_reference
detection = lbh_reference
time.diagnostics = TRUE
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE)
# make it a data frame if selection table
if (warbleR::is_selection_table(detection))
detection <- as.data.frame(detection)
# make it a data frame if selection table
if (warbleR::is_selection_table(reference))
reference <- as.data.frame(reference)
# remove rows with no info
detection <- detection[!is.na(detection$start), ]
if (nrow(detection) > 0)
# double checking happens inside label_detection()
labeled_detection <- label_detection(reference = reference, detection = detection, parallel = parallel, pb = pb)
# # add row labels to reference for getting false negatives
reference$..row.id <- 1:nrow(reference)
# duration of corresponding selection in reference
labeled_detection$reference.duration <- sapply(1:nrow(labeled_detection), function(x){
if (is.na(labeled_detection$reference.row[x])) NA  else
if (grepl("-", labeled_detection$reference.row[x]))  NA else
reference$end[as.numeric(labeled_detection$reference.row[x])] - reference$start[as.numeric(labeled_detection$reference.row[x])]
})
# look at detections matching 1 training selection at the time
performance_list <- lapply(unique(labeled_detection$sound.files), function(z){
# get subset for that sound file
sub_detec <- labeled_detection[labeled_detection$sound.files == z, ]
sub_ref <- reference[reference$sound.files == z, ]
# get row index in reference for detected signals
detected_reference_rows <- unique(na.omit(unlist(lapply(sub_detec$reference.row, function(x) unlist(strsplit(as.character(x), "-"))))))
performance <- data.frame(
sound.files = z,
true.positives = length(detected_reference_rows),
false.positives = sum(grepl("false", sub_detec$detection.class)),
false.negatives = sum(!sub_ref$..row.id %in% detected_reference_rows),
split.positives = length(unique(
unlist(lapply(sub_detec$reference.row[grepl("split)", sub_detec$detection.class)], function(x) unlist(strsplit(x, "-")))))),
merged.positives = sum(grepl("merge", sub_detec$detection.class)),
mean.duration.true.positives = mean((sub_detec$end - sub_detec$start)[grep("true", sub_detec$detection.class)]),
mean.duration.false.positives = mean((sub_detec$end - sub_detec$start)[grep("false", sub_detec$detection.class)]),
mean.duration.false.negatives = mean((sub_ref$end - sub_ref$start)[!sub_ref$..row.id %in% detected_reference_rows]),
overlap.to.true.positives = if(any(!is.na(sub_detec$overlap))) mean(sub_detec$overlap, na.rm = TRUE) else NA,
proportional.duration.true.positives = mean(sub_detec$reference.duration, na.rm = TRUE) / mean((sub_ref$end - sub_ref$start)[sub_ref$..row.id %in% detected_reference_rows], na.rm = TRUE),
stringsAsFactors = FALSE
)
# add duty cycle
if (!is.null(path) & time.diagnostics){
# get file durations
performance$duty.cycle <- sum((sub_detec$end - sub_detec$start), na.rm = TRUE) / warbleR::duration_sound_files(files = z, path = path)$duration
}
# add sensitivity and specificity
performance$sensitivity <- length(detected_reference_rows) / nrow(sub_ref)
performance$specificity <-  if (nrow(sub_detec) > 0 & length(detected_reference_rows) > 0) length(detected_reference_rows) / (nrow(sub_ref) + sum(grep("false", sub_detec$detection.class))) else 0
# replace NaNs with NA
for(i in 1:ncol(performance))
if (is.nan(performance[, i])) performance[, i] <- NA
# fix values when no false positives or true positives
performance$false.positives[performance$false.positives < 0] <- 0
performance$mean.duration.false.positives[is.na(performance$mean.duration.false.positives) | performance$false.positives == 0] <- NA
performance$mean.duration.true.positives[is.na(performance$mean.duration.true.positives) | performance$true.positives == 0] <- NA
# make sensitvities higher than 1 (because of split positives) 1
performance$sensitivity[performance$sensitivity > 1] <- 1
return(performance)
})
# add diagnostics of files in reference but not in detection
if (any(!reference$sound.files %in% unique(labeled_detection$sound.files))){
no_detec <- data.frame(
sound.files = setdiff(reference$sound.files, unique(labeled_detection$sound.files)),
true.positives = 0,
false.positives = 0,
false.negatives = sapply(setdiff(reference$sound.files, unique(labeled_detection$sound.files)), function(x) sum(reference$sound.files == x)),
split.positives = NA,
merged.positives = NA,
mean.duration.true.positives = NA,
mean.duration.false.positives = NA,
mean.duration.false.negatives = sapply(setdiff(reference$sound.files, unique(labeled_detection$sound.files)), function(x) mean((reference$end - reference$start)[reference$sound.files == x])),
overlap.to.true.positives = NA,
proportional.duration.true.positives = NA,
sensitivity = 0,
specificity =  0,
stringsAsFactors = FALSE
)
# add duty cycle
if (!is.null(path) & time.diagnostics)
no_detec$duty.cycle <- 0
performance_list[[length(performance_list) + 1]] <- no_detec
}
# put in a single data frame
performance_df <- do.call(rbind, performance_list)
performance_df[ , match(names(performance_df), c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"))]
match(names(performance_df), c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"))
names(performance_df)
names(performance_df)
match(c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"), names(performance_df))
match(c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"), names(performance_df), nomatch = NULL)
na.omit(match(c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"), names(performance_df)))
# sort columns
performance_df <- performance_df[ , na.omit(match(c("sound.files", "true.positives", "false.positives", "false.negatives", "split.positives", "merged.positives", "mean.duration.true.positives", "mean.duration.false.positives", "mean.duration.false.negatives", "overlap.to.true.positives", "proportional.duration.true.positives", "duty.cycle", "sensitivity", "specificity"), names(performance_df)))]
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE)
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE)
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE, by.sound.file = FALSE)
source("~/Dropbox/R_package_testing/ohun/R/summarize_diagnostic.R")
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE, by.sound.file = FALSE)
performance_df
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE, by.sound.file = FALSE)
# perfect detection
diagnose_detection(reference = lbh_reference, detection = lbh_reference, time.diagnostics = TRUE, path = tempdir())
# an extra one in detection
diagnose_detection(reference = lbh_reference[-1, ], detection = lbh_reference, time.diagnostics = TRUE)
# and extra sound file in reference
diagnose_detection(reference = lbh_reference, detection = lbh_reference[lbh_reference$sound.files != "Phae.long1.wav", ], time.diagnostics = TRUE)
# and extra sound file in detection
diagnose_detection(reference = lbh_reference[lbh_reference$sound.files != "Phae.long1.wav", ], detection = lbh_reference, time.diagnostics = TRUE)
# and extra sound file in detection by sound file
dd <- diagnose_detection(reference = lbh_reference[lbh_reference$sound.files != "Phae.long1.wav", ], detection = lbh_reference, time.diagnostics = TRUE, by.sound.file = TRUE)
# with path
dd <- diagnose_detection(reference = lbh_reference[lbh_reference$sound.files != "Phae.long1.wav", ], detection = lbh_reference, time.diagnostics = TRUE, by.sound.file = TRUE, path = tempdir())
# get summary
summarize_diagnostic(dd)
# merged detection
lbh_selec2 <- lbh_reference
lbh_selec2$end[11] <- 1
lbh_selec2$end[12] <- 1
diagnose_detection(reference = lbh_selec2, detection = lbh_reference, time.diagnostics = FALSE, by.sound.file = TRUE)
lbh_selec2$end
lbh_reference
lbh_selec2$end[11] <- 3
lbh_selec2$end[12] <- 3
diagnose_detection(reference = lbh_selec2, detection = lbh_reference, time.diagnostics = FALSE, by.sound.file = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
#built site
pkgdown::build_site(lazy = TRUE, preview = TRUE, examples = FALSE)
