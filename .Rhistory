if (!is.null(lty))
lty <- rep_len(lty, nx)
angle <- rep(angle, nx)
if (!is.null(density))
density <- rep_len(density, nx)
twopi <- if (clockwise)
-2 * pi else 2 * pi
radius <- 100
t2xy <- function(t) {
t2p <- twopi * t + init.angle * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
# get polygon for each sub space
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
lines(c(P$x[1], 0), c(P$y[1], 0))
lines(c(0, P$x[n]), c(0, P$y[n]))
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- Polygons(list(Polygon(pol_df)), ID = 1)
spp <- SpatialPolygons(list(poly))
return(spp)
})
# get
# whchs <- sapply(polys, function(x) {
centroids <- sapply(polys, function(x) {
whch_within  <- which(!is.na(sp::over(x = SpatialPoints(space[, 1:2]),  y = SpatialPolygons(x@polygons), returnList = FALSE)))
if (length(whch_within) > 0){
if (length(whch_within) > 1) {
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(1:nrow(sub_space), function(x)
dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
} else
centroid <- sub_space$...NROW[whch_within]
} else
centroid <- NA
return(centroid)
# return(which.min(dists_to_centroid))
})
return(centroids)
}
# acoustic.space
polys <- pie2(n = 6, col = "white", space = acoustic.space)
#
# plot(polys[[3]], add = T, col = "green")
# plot(polys[[2]], add = T, col = "blue")
# plot(polys[[1]], add = T, col = "red")
points(x = mean(acoustic.space[,1]), y = mean(acoustic.space[,2]), pch = 20, col = "black", cex = 4)
points(acoustic.space)
points(acoustic.space[polys, ], col = "red", pch = 20, cex = 3)
pie2 <- function(reference = lbh_reference, n, space = NULL, clockwise = FALSE,
init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45,
col = NULL, border = NULL, lty = NULL, xlim = NULL, ylim = NULL)
{
x <- rep(1, n)
space <- space[, 1:2]
space <- data.frame(space)
space$...NROW <- 1:nrow(  space)
if (is.null(xlim))
xlim <- range(space[, 1]) * 2
if (is.null(ylim))
ylim <- range(space[, 2]) * 2
if (!is.numeric(x) || any(is.na(x) | x < 0))
stop("'x' values must be positive.")
if (is.null(labels))
labels <- as.character(seq_along(x)) else labels <- as.graphicsAnnot(labels)
x <- c(0, cumsum(x)/sum(x))
dx <- diff(x)
nx <- length(dx)
plot.new()
pin <- par("pin")
if (pin[1L] > pin[2L])
xlim <- (pin[1L]/pin[2L]) * xlim else ylim <- (pin[2L]/pin[1L]) * ylim
# dev.hold()
# on.exit(dev.flush())
plot.window(xlim, ylim, "")
if (is.null(col))
col <- if (is.null(density))
c("white", "lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk") else par("fg")
if (!is.null(col))
col <- rep_len(col, nx)
if (!is.null(border))
border <- rep_len(border, nx)
if (!is.null(lty))
lty <- rep_len(lty, nx)
angle <- rep(angle, nx)
if (!is.null(density))
density <- rep_len(density, nx)
twopi <- if (clockwise)
-2 * pi else 2 * pi
radius <- 100
t2xy <- function(t) {
t2p <- twopi * t + init.angle * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
# get polygon for each sub space
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
lines(c(P$x[1], 0), c(P$y[1], 0), lty = 4)
lines(c(0, P$x[n]), c(0, P$y[n]), ly = 4)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- Polygons(list(Polygon(pol_df)), ID = 1)
spp <- SpatialPolygons(list(poly))
return(spp)
})
# get
# whchs <- sapply(polys, function(x) {
centroids <- sapply(polys, function(x) {
whch_within  <- which(!is.na(sp::over(x = SpatialPoints(space[, 1:2]),  y = SpatialPolygons(x@polygons), returnList = FALSE)))
if (length(whch_within) > 0){
if (length(whch_within) > 1) {
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(1:nrow(sub_space), function(x)
dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
} else
centroid <- sub_space$...NROW[whch_within]
} else
centroid <- NA
return(centroid)
# return(which.min(dists_to_centroid))
})
return(centroids)
}
# acoustic.space
polys <- pie2(n = 6, col = "white", space = acoustic.space)
#
# plot(polys[[3]], add = T, col = "green")
# plot(polys[[2]], add = T, col = "blue")
# plot(polys[[1]], add = T, col = "red")
points(x = mean(acoustic.space[,1]), y = mean(acoustic.space[,2]), pch = 20, col = "black", cex = 4)
points(acoustic.space)
points(acoustic.space[polys, ], col = "red", pch = 20, cex = 3)
pie2 <- function(reference = lbh_reference, n, space = NULL, clockwise = FALSE,
init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45,
col = NULL, border = NULL, lty = NULL, xlim = NULL, ylim = NULL)
{
x <- rep(1, n)
space <- space[, 1:2]
space <- data.frame(space)
space$...NROW <- 1:nrow(  space)
if (is.null(xlim))
xlim <- range(space[, 1]) * 2
if (is.null(ylim))
ylim <- range(space[, 2]) * 2
if (!is.numeric(x) || any(is.na(x) | x < 0))
stop("'x' values must be positive.")
if (is.null(labels))
labels <- as.character(seq_along(x)) else labels <- as.graphicsAnnot(labels)
x <- c(0, cumsum(x)/sum(x))
dx <- diff(x)
nx <- length(dx)
plot.new()
pin <- par("pin")
if (pin[1L] > pin[2L])
xlim <- (pin[1L]/pin[2L]) * xlim else ylim <- (pin[2L]/pin[1L]) * ylim
# dev.hold()
# on.exit(dev.flush())
plot.window(xlim, ylim, "")
if (is.null(col))
col <- if (is.null(density))
c("white", "lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk") else par("fg")
if (!is.null(col))
col <- rep_len(col, nx)
if (!is.null(border))
border <- rep_len(border, nx)
if (!is.null(lty))
lty <- rep_len(lty, nx)
angle <- rep(angle, nx)
if (!is.null(density))
density <- rep_len(density, nx)
twopi <- if (clockwise)
-2 * pi else 2 * pi
radius <- 100
t2xy <- function(t) {
t2p <- twopi * t + init.angle * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
# get polygon for each sub space
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
lines(c(P$x[1], 0), c(P$y[1], 0), lty = 4)
lines(c(0, P$x[n]), c(0, P$y[n]), lty = 4)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- Polygons(list(Polygon(pol_df)), ID = 1)
spp <- SpatialPolygons(list(poly))
return(spp)
})
# get
# whchs <- sapply(polys, function(x) {
centroids <- sapply(polys, function(x) {
whch_within  <- which(!is.na(sp::over(x = SpatialPoints(space[, 1:2]),  y = SpatialPolygons(x@polygons), returnList = FALSE)))
if (length(whch_within) > 0){
if (length(whch_within) > 1) {
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(1:nrow(sub_space), function(x)
dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
} else
centroid <- sub_space$...NROW[whch_within]
} else
centroid <- NA
return(centroid)
# return(which.min(dists_to_centroid))
})
return(centroids)
}
# acoustic.space
polys <- pie2(n = 6, col = "white", space = acoustic.space)
#
# plot(polys[[3]], add = T, col = "green")
# plot(polys[[2]], add = T, col = "blue")
# plot(polys[[1]], add = T, col = "red")
points(x = mean(acoustic.space[,1]), y = mean(acoustic.space[,2]), pch = 20, col = "black", cex = 4)
points(acoustic.space)
points(acoustic.space[polys, ], col = "red", pch = 20, cex = 3)
pie2 <- function(reference = lbh_reference, n, space = NULL, clockwise = FALSE,
init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45,
col = NULL, border = NULL, lty = NULL, xlim = NULL, ylim = NULL)
{
x <- rep(1, n)
space <- space[, 1:2]
space <- data.frame(space)
space$...NROW <- 1:nrow(  space)
if (is.null(xlim))
xlim <- range(space[, 1]) * 2
if (is.null(ylim))
ylim <- range(space[, 2]) * 2
if (!is.numeric(x) || any(is.na(x) | x < 0))
stop("'x' values must be positive.")
if (is.null(labels))
labels <- as.character(seq_along(x)) else labels <- as.graphicsAnnot(labels)
x <- c(0, cumsum(x)/sum(x))
dx <- diff(x)
nx <- length(dx)
plot.new()
pin <- par("pin")
if (pin[1L] > pin[2L])
xlim <- (pin[1L]/pin[2L]) * xlim else ylim <- (pin[2L]/pin[1L]) * ylim
# dev.hold()
# on.exit(dev.flush())
plot.window(xlim, ylim, "")
if (is.null(col))
col <- if (is.null(density))
c("white", "lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk") else par("fg")
if (!is.null(col))
col <- rep_len(col, nx)
if (!is.null(border))
border <- rep_len(border, nx)
if (!is.null(lty))
lty <- rep_len(lty, nx)
angle <- rep(angle, nx)
if (!is.null(density))
density <- rep_len(density, nx)
twopi <- if (clockwise)
-2 * pi else 2 * pi
radius <- 100
t2xy <- function(t) {
t2p <- twopi * t + init.angle * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
# get polygon for each sub space
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
lines(c(P$x[1], 0), c(P$y[1], 0), lty = 2)
lines(c(0, P$x[n]), c(0, P$y[n]), lty = 4)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- Polygons(list(Polygon(pol_df)), ID = 1)
spp <- SpatialPolygons(list(poly))
return(spp)
})
# get
# whchs <- sapply(polys, function(x) {
centroids <- sapply(polys, function(x) {
whch_within  <- which(!is.na(sp::over(x = SpatialPoints(space[, 1:2]),  y = SpatialPolygons(x@polygons), returnList = FALSE)))
if (length(whch_within) > 0){
if (length(whch_within) > 1) {
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(1:nrow(sub_space), function(x)
dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
} else
centroid <- sub_space$...NROW[whch_within]
} else
centroid <- NA
return(centroid)
# return(which.min(dists_to_centroid))
})
return(centroids)
}
# acoustic.space
polys <- pie2(n = 6, col = "white", space = acoustic.space)
#
# plot(polys[[3]], add = T, col = "green")
# plot(polys[[2]], add = T, col = "blue")
# plot(polys[[1]], add = T, col = "red")
points(x = mean(acoustic.space[,1]), y = mean(acoustic.space[,2]), pch = 20, col = "black", cex = 4)
points(acoustic.space)
points(acoustic.space[polys, ], col = "red", pch = 20, cex = 3)
pie2 <- function(reference = lbh_reference, n, space = NULL, clockwise = FALSE,
init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45,
col = NULL, border = NULL, lty = NULL, xlim = NULL, ylim = NULL)
{
x <- rep(1, n)
space <- space[, 1:2]
space <- data.frame(space)
space$...NROW <- 1:nrow(  space)
if (is.null(xlim))
xlim <- range(space[, 1]) * 2
if (is.null(ylim))
ylim <- range(space[, 2]) * 2
if (!is.numeric(x) || any(is.na(x) | x < 0))
stop("'x' values must be positive.")
if (is.null(labels))
labels <- as.character(seq_along(x)) else labels <- as.graphicsAnnot(labels)
x <- c(0, cumsum(x)/sum(x))
dx <- diff(x)
nx <- length(dx)
plot.new()
pin <- par("pin")
if (pin[1L] > pin[2L])
xlim <- (pin[1L]/pin[2L]) * xlim else ylim <- (pin[2L]/pin[1L]) * ylim
# dev.hold()
# on.exit(dev.flush())
plot.window(xlim, ylim, "")
if (is.null(col))
col <- if (is.null(density))
c("white", "lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk") else par("fg")
if (!is.null(col))
col <- rep_len(col, nx)
if (!is.null(border))
border <- rep_len(border, nx)
if (!is.null(lty))
lty <- rep_len(lty, nx)
angle <- rep(angle, nx)
if (!is.null(density))
density <- rep_len(density, nx)
twopi <- if (clockwise)
-2 * pi else 2 * pi
radius <- 100
t2xy <- function(t) {
t2p <- twopi * t + init.angle * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
# get polygon for each sub space
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
lines(c(P$x[1], 0), c(P$y[1], 0), lty = 2)
lines(c(0, P$x[n]), c(0, P$y[n]), lty = 2)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- Polygons(list(Polygon(pol_df)), ID = 1)
spp <- SpatialPolygons(list(poly))
return(spp)
})
# get
# whchs <- sapply(polys, function(x) {
centroids <- sapply(polys, function(x) {
whch_within  <- which(!is.na(sp::over(x = SpatialPoints(space[, 1:2]),  y = SpatialPolygons(x@polygons), returnList = FALSE)))
if (length(whch_within) > 0){
if (length(whch_within) > 1) {
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(1:nrow(sub_space), function(x)
dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
} else
centroid <- sub_space$...NROW[whch_within]
} else
centroid <- NA
return(centroid)
# return(which.min(dists_to_centroid))
})
return(centroids)
}
# acoustic.space
polys <- pie2(n = 6, col = "white", space = acoustic.space)
#
# plot(polys[[3]], add = T, col = "green")
# plot(polys[[2]], add = T, col = "blue")
# plot(polys[[1]], add = T, col = "red")
points(x = mean(acoustic.space[,1]), y = mean(acoustic.space[,2]), pch = 20, col = "black", cex = 4)
points(acoustic.space)
points(acoustic.space[polys, ], col = "red", pch = 20, cex = 3)
pie2 <- function(reference = lbh_reference, n, space = NULL, clockwise = FALSE,
init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45,
col = NULL, border = NULL, lty = NULL, xlim = NULL, ylim = NULL)
{
x <- rep(1, n)
space <- space[, 1:2]
space <- data.frame(space)
space$...NROW <- 1:nrow(  space)
if (is.null(xlim))
xlim <- range(space[, 1]) * 2
if (is.null(ylim))
ylim <- range(space[, 2]) * 2
if (!is.numeric(x) || any(is.na(x) | x < 0))
stop("'x' values must be positive.")
if (is.null(labels))
labels <- as.character(seq_along(x)) else labels <- as.graphicsAnnot(labels)
x <- c(0, cumsum(x)/sum(x))
dx <- diff(x)
nx <- length(dx)
plot.new()
pin <- par("pin")
if (pin[1L] > pin[2L])
xlim <- (pin[1L]/pin[2L]) * xlim else ylim <- (pin[2L]/pin[1L]) * ylim
# dev.hold()
# on.exit(dev.flush())
plot.window(xlim, ylim, "")
if (is.null(col))
col <- if (is.null(density))
c("white", "lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk") else par("fg")
if (!is.null(col))
col <- rep_len(col, nx)
if (!is.null(border))
border <- rep_len(border, nx)
if (!is.null(lty))
lty <- rep_len(lty, nx)
angle <- rep(angle, nx)
if (!is.null(density))
density <- rep_len(density, nx)
twopi <- if (clockwise)
-2 * pi else 2 * pi
radius <- 100
t2xy <- function(t) {
t2p <- twopi * t + init.angle * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
# get polygon for each sub space
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
lines(c(P$x[1], 0), c(P$y[1], 0), lty = 3)
lines(c(0, P$x[n]), c(0, P$y[n]), lty = 3)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- Polygons(list(Polygon(pol_df)), ID = 1)
spp <- SpatialPolygons(list(poly))
return(spp)
})
# get
# whchs <- sapply(polys, function(x) {
centroids <- sapply(polys, function(x) {
whch_within  <- which(!is.na(sp::over(x = SpatialPoints(space[, 1:2]),  y = SpatialPolygons(x@polygons), returnList = FALSE)))
if (length(whch_within) > 0){
if (length(whch_within) > 1) {
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(1:nrow(sub_space), function(x)
dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
} else
centroid <- sub_space$...NROW[whch_within]
} else
centroid <- NA
return(centroid)
# return(which.min(dists_to_centroid))
})
return(centroids)
}
# acoustic.space
polys <- pie2(n = 6, col = "white", space = acoustic.space)
#
# plot(polys[[3]], add = T, col = "green")
# plot(polys[[2]], add = T, col = "blue")
# plot(polys[[1]], add = T, col = "red")
points(x = mean(acoustic.space[,1]), y = mean(acoustic.space[,2]), pch = 20, col = "black", cex = 4)
points(acoustic.space)
points(acoustic.space[polys, ], col = "red", pch = 20, cex = 3)
