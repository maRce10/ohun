#            n.templates = 3)
# acoustic.space
templates <- find_templates(n.sub.spaces = 2, space = g3[, c("Dimension_1", "Dimension_2")], reference = g3_ref, plot = F)
# library(sf)
library(sp)
n <- 50
r = 1.5 * sqrt(runif(n = n * 1.5))
theta = runif(n = n * 1.5) * 2 * pi
x = 2 + r * cos(theta)
y = 2 + r * sin(theta)
g3 <- data.frame(ID = "G3", Dimension_1 = x, Dimension_2 = y)
g3_ref <- data.frame(sound.files = "1.wav", selec = 1:nrow(g3), start = 1, end = 2)
# acoustic.space
templates <- find_templates(n.sub.spaces = 2, space = g3[, c("Dimension_1", "Dimension_2")], reference = g3_ref, plot = F)
# get_templates(reference = g3_ref,
#            acoustic.space = g3[, c("Dimension_1", "Dimension_2")],
#            path = ".",
#            n.templates = 3)
# library(sf)
library(sp)
n <- 50
r = 1.5 * sqrt(runif(n = n * 1.5))
theta = runif(n = n * 1.5) * 2 * pi
x = 2 + r * cos(theta)
y = 2 + r * sin(theta)
g3 <- data.frame(ID = "G3", Dimension_1 = x, Dimension_2 = y)
g3_ref <- data.frame(sound.files = "1.wav", selec = 1:nrow(g3), start = 1, end = 2)
# acoustic.space
templates <- find_templates(n.sub.spaces = 2, space = g3[, c("Dimension_1", "Dimension_2")], reference = g3_ref, plot = T)
# get_templates(reference = g3_ref,
#            acoustic.space = g3[, c("Dimension_1", "Dimension_2")],
#            path = ".",
#            n.templates = 3)
reference = g3_ref
acoustic.space = g3[, c("Dimension_1", "Dimension_2")]
path = "."
n.templates = 3
if (!is.null(acoustic.space))
if (nrow(reference) != nrow(acoustic.space))
stop("'reference' and 'acoustic.space' must have the same number of columns")
if (is.null(acoustic.space)) {
spectral_parameters <- spectro_analysis(reference, path = path, ...)
# remove columns with NAs
spectral_parameters <-
spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <-
stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
# get variance by PC
variance_pca <- summary(pca)$importance
# number of PCs to keep
pcs_keep <- sum(variance_pca[3, ] <= variance.cutoff) + 1
# print info
cat(crayon::silver(
paste0(
pcs_keep,
" principal components were kept which explained ",
round(variance_pca[3, pcs_keep], 2),
" of the variance"
)
))
# keep those as acoustic space
acoustic.space <- pca$x[, 1:pcs_keep]
}
# get centroid
centroid_coors <- colMeans(acoustic.space)
# and distance to centroid
dists_to_centroid <-
unlist(warbleR:::pblapply_wrblr_int(pbar = FALSE, 1:nrow(acoustic.space), function(x)
dist(
rbind(acoustic.space[x, ], centroid_coors)
)))
# get quantile distribution of distances from centroid
dist_quantiles <-
stats::quantile(
x = dists_to_centroid,
probs = seq(0, 1, length.out = n.sub.spaces + 1)[1:(n.sub.spaces)],
digits = 1
)
n.sub.spaces = 3
if (!is.null(acoustic.space))
if (nrow(reference) != nrow(acoustic.space))
stop("'reference' and 'acoustic.space' must have the same number of columns")
if (is.null(acoustic.space)) {
spectral_parameters <- spectro_analysis(reference, path = path, ...)
# remove columns with NAs
spectral_parameters <-
spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <-
stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
# get variance by PC
variance_pca <- summary(pca)$importance
# number of PCs to keep
pcs_keep <- sum(variance_pca[3, ] <= variance.cutoff) + 1
# print info
cat(crayon::silver(
paste0(
pcs_keep,
" principal components were kept which explained ",
round(variance_pca[3, pcs_keep], 2),
" of the variance"
)
))
# keep those as acoustic space
acoustic.space <- pca$x[, 1:pcs_keep]
}
# get centroid
centroid_coors <- colMeans(acoustic.space)
# and distance to centroid
dists_to_centroid <-
unlist(warbleR:::pblapply_wrblr_int(pbar = FALSE, 1:nrow(acoustic.space), function(x)
dist(
rbind(acoustic.space[x, ], centroid_coors)
)))
# get quantile distribution of distances from centroid
dist_quantiles <-
stats::quantile(
x = dists_to_centroid,
probs = seq(0, 1, length.out = n.sub.spaces + 1)[1:(n.sub.spaces)],
digits = 1
)
# get indices of selections closer to those quantiles
template_indx <-
sapply(dist_quantiles, function(x)
which.min(abs(dists_to_centroid - x)))
# extract those selections
templates <- reference[template_indx, ]
templates$distance.quantile <- names(template_indx)
# save as a selection table
templates <-
warbleR::selection_table(templates, path = path, pb = FALSE)
#' @title Find templates more similar to other signals in a reference table
#'
#' @description \code{get_templates} find the signals that are closer to the acoustic space  centroid (i.e. close to the average acoustic structure) in a reference table.
#' @usage get_templates(reference, acoustic.space = NULL, variance.cutoff = 0.7, path = ".",
#' n.sub.spaces = 1, ...)
#' @param reference Selection table (using the warbleR package's format, see \code{\link[warbleR]{selection_table}}) or data frame with columns
#' for sound file name (sound.files), selection number (selec), and start and end time of signal
#' (start and end).
#' @param acoustic.space Numeric matrix or data frame with the two dimensions of a custom acoustic space to be used for finding templates. if not supplied the acoustic space is calculated internally (default). Optional. Note that the function assumes that 'reference' and 'acoustic.space' refer to the same signals and similarly ordered.
#' @param path Character string containing the directory path where the sound files are located.
#'The current working directory is used as default.
#'@param n.sub.spaces Integer vector of length 1 with the number of templates to be returned. If 1 only the signal closer to the centroid is returned. If higher than 1 the function returns additional signals that are representative of the acoustic space, defined as those equally spaced across the distribution of distances to the centroid.
#' @param ... Additional arguments to be passed to \code{\link[warbleR]{spectro_analysis}} for further customization when measuring parameters to calculate the acoustic space.
#' @return The function returns a 'selection_table' (warbleR package's formats, see \code{\link[warbleR]{selection_table}}) or data frame (if sound files can't be found) containing the start and end of each signal by
#'   sound file. If no signal was detected for a sound file it is not included in the output data frame.
#' @export
#' @name get_templates
#' @details This function finds signals that are representative of the acoustic variation of the signals in a reference table. This is done by finding the signals closer to the centroid of the acoustic space. If the acoustic space is not supplied ('acoustic.space' argument) then the function will estimate it by measuring several acoustic parameters using the function \code{\link[warbleR]{spectro_analysis}} and summarizing it with Principal Component Analysis (after z-transforming parameters) using the function \code{\link[stats]{prcomp}}. The rationale here is that a signal closest to the average signal structure is more likely to share structural features with most signals across the acoustic space than a signal in the periphery of the space.
#' If only 1 template is required the function returns that closest to the acoustic space centroid. If more than 1 templated is required additional signals are returned that are representative of the acoustic space, defined as those equally spaced across the distribution of distances to the centroid. A column 'distance.quantile' is included in the output selection table that identifies the quantile of the distance to the centroid that each selection represents. Custom acoustic spaces can be supplied with argument 'acoustic.space'.
#'
#' @examples {
#' # Save example files into temporary working directory
#' data("lbh1", "lbh2", "lbh_reference")
#' writeWave(lbh1, file.path(tempdir(), "lbh1.wav"))
#' writeWave(lbh2, file.path(tempdir(), "lbh2.wav"))
#'
#' # get a single mean template
#' template <- get_templates(reference = lbh_reference, path = tempdir())
#'
#' # get 3 templates
#' template <- get_templates(reference = lbh_reference, n.sub.spaces = 3, path = tempdir())
#' }
#'
#' @references {
#' Araya-Salas, M. (2021), ohun: automatic detection of acoustic signals. R package version 0.1.0.
#' }
#' @seealso \code{\link{template_detector}}
#' @author Marcelo Araya-Salas (\email{marcelo.araya@@ucr.ac.cr}). Implements a
#' modified version of the timer function from seewave.
#last modification on feb-2022 (MAS)
get_templates <-
function(reference,
acoustic.space = NULL,
variance.cutoff = 0.7,
path = ".",
n.sub.spaces = 1,
...) {
if (!is.null(acoustic.space))
if (nrow(reference) != nrow(acoustic.space))
stop("'reference' and 'acoustic.space' must have the same number of columns")
if (is.null(acoustic.space)) {
spectral_parameters <- spectro_analysis(reference, path = path, ...)
# remove columns with NAs
spectral_parameters <-
spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <-
stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
# get variance by PC
variance_pca <- summary(pca)$importance
# number of PCs to keep
pcs_keep <- sum(variance_pca[3, ] <= variance.cutoff) + 1
# print info
cat(crayon::silver(
paste0(
pcs_keep,
" principal components were kept which explained ",
round(variance_pca[3, pcs_keep], 2),
" of the variance"
)
))
# keep those as acoustic space
acoustic.space <- pca$x[, 1:pcs_keep]
}
# # get centroid
# centroid_coors <- colMeans(acoustic.space)
#
# # and distance to centroid
# dists_to_centroid <-
#   unlist(warbleR:::pblapply_wrblr_int(pbar = FALSE, 1:nrow(acoustic.space), function(x)
#     dist(
#       rbind(acoustic.space[x, ], centroid_coors)
#     )))
#
# # get quantile distribution of distances from centroid
# dist_quantiles <-
#   stats::quantile(
#     x = dists_to_centroid,
#     probs = seq(0, 1, length.out = n.sub.spaces + 1)[1:(n.sub.spaces)],
#     digits = 1
#   )
#
# # get indices of selections closer to those quantiles
# template_indx <-
#   sapply(dist_quantiles, function(x)
#     which.min(abs(dists_to_centroid - x)))
template_indx <- find_templates(reference = reference, n.sub.spaces = n.sub.spaces, space = acoustic.space, plot = TRUE)
template_indx <- template_indx[!is.na(template_indx)]
# extract those selections
templates <- reference[template_indx, ]
templates$template <- names(template_indx)
# save as a selection table
# templates <-
#   warbleR::selection_table(templates, path = path, pb = FALSE)
return(templates)
}
# internal function to find (and plot) templates in the acoustic space
find_templates <- function(reference = NULL, n.sub.spaces, space = NULL, plot = TRUE)
{
x <- rep(1, n.sub.spaces)
space <- space[, 1:2]
space <- data.frame(space)
space$...NROW <- 1:nrow(space)
# mean center
mean_dim1 <- mean(space[, 1])
mean_dim2 <- mean(space[, 2])
# center at 0
space[, 1] <-  space[, 1] - mean_dim1
space[, 2] <-  space[, 2] - mean_dim2
x <- c(0, cumsum(x)/sum(x))
dx <- diff(x)
nx <- length(dx)
radius <- 100
t2xy <- function(t) {
t2p <- 2 * pi * t + 0 * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
if (plot)
plot(space[, 1] + mean_dim1, space[, 2] + mean_dim2, pch = 20, cex = 2, col = "#4401544D", xlab = "Dimension 1", ylab = "Dimension 2")
# get polygon for each sub space
if (n.sub.spaces > 1)
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
if (plot){
lines(c(P$x[1], 0) + mean_dim1, c(P$y[1], 0) + mean_dim2, lty = 3)
lines(c(0, P$x[n]) + mean_dim1, c(0, P$y[n]) + mean_dim2, lty = 3)
}
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- sp::Polygons(list(sp::Polygon(pol_df)), ID = 1)
spp <- sp::SpatialPolygons(list(poly))
return(spp)
}) else polys <- vector()
# get  centroids, the first one is the centroid of the enitre space
centroids <- vector(length = length(polys) + 1)
for (i in 0:length(polys)){
if (i > 0)
whch_within  <- which(!is.na(sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE))) else whch_within <- 1:nrow(space)
if (length(whch_within) > 0){
if (length(whch_within) > 1) {
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(1:nrow(sub_space), function(x)
stats::dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
} else
centroid <- sub_space$...NROW[whch_within]
} else
centroid <- NA
centroids[i + 1] <- centroid
}
names(centroids) <-  if (n.sub.spaces > 1) c("centroid", paste0("templ-", 1:(length(centroids) - 1))) else "centroid"
# plot
if (plot){
points(x = space[centroids, 1] + mean_dim1, y = space[centroids, 2] + mean_dim2, col = "#FDE725FF", pch = 1, cex = 1.8, lwd = 4)
text(x = space[centroids, 1] + mean_dim1, y = space[centroids, 2] + mean_dim2, labels = names(centroids), pos = 4)
}
return(centroids)
}
source("~/Dropbox/R_package_testing/ohun/R/get_templates.R")
get_templates(reference = g3_ref,
acoustic.space = g3[, c("Dimension_1", "Dimension_2")],
path = ".",
n.sub.spaces = 3)
# library(sf)
library(sp)
n <- 50
r = 1.5 * sqrt(runif(n = n * 1.5))
theta = runif(n = n * 1.5) * 2 * pi
x = 2 + r * cos(theta)
y = 2 + r * sin(theta)
g3 <- data.frame(ID = "G3", Dimension_1 = x, Dimension_2 = y)
g3_ref <- data.frame(sound.files = "1.wav", selec = 1:nrow(g3), start = 1, end = 2)
# acoustic.space
# templates <- find_templates(n.sub.spaces = 2, space = g3[, c("Dimension_1", "Dimension_2")], reference = g3_ref, plot = T)
get_templates(reference = g3_ref,
acoustic.space = g3[, c("Dimension_1", "Dimension_2")],
path = ".",
n.sub.spaces = 3)
# library(sf)
library(sp)
n <- 50
r = 1.5 * sqrt(runif(n = n * 1.5))
theta = runif(n = n * 1.5) * 2 * pi
x = 2 + r * cos(theta)
y = 2 + r * sin(theta)
g3 <- data.frame(ID = "G3", Dimension_1 = x, Dimension_2 = y)
g3_ref <- data.frame(sound.files = "1.wav", selec = 1:nrow(g3), start = 1, end = 2)
# acoustic.space
# templates <- find_templates(n.sub.spaces = 2, space = g3[, c("Dimension_1", "Dimension_2")], reference = g3_ref, plot = T)
get_templates(reference = g3_ref,
acoustic.space = g3[, c("Dimension_1", "Dimension_2")],
path = ".",
n.sub.spaces = 3)
# library(sf)
library(sp)
n <- 50
r = 1.5 * sqrt(runif(n = n * 1.5))
theta = runif(n = n * 1.5) * 2 * pi
x = 2 + r * cos(theta)
y = 2 + r * sin(theta)
g3 <- data.frame(ID = "G3", Dimension_1 = x, Dimension_2 = y)
g3_ref <- data.frame(sound.files = "1.wav", selec = 1:nrow(g3), start = 1, end = 2)
# acoustic.space
# templates <- find_templates(n.sub.spaces = 2, space = g3[, c("Dimension_1", "Dimension_2")], reference = g3_ref, plot = T)
get_templates(reference = g3_ref,
acoustic.space = g3[, c("Dimension_1", "Dimension_2")],
path = ".",
n.sub.spaces = 3)
FUN <- "get_templates"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
#remove images and sound files
rm.sf.img()
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
data("lbh_reference")
list.files(tempdir(), pattern = ".wav")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
source("~/Dropbox/R_package_testing/ohun/R/get_templates.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
source("~/Dropbox/R_package_testing/ohun/R/get_templates.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
# with custom acoustic space
spectral_parameters <- spectro_analysis(reference, path = tempdir())
# with custom acoustic space
spectral_parameters <- spectro_analysis(lbh_reference, path = tempdir())
# remove columns with NAs
spectral_parameters <- spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <- stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, acoustic.space = pca$x[, 1:2], path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  2, acoustic.space = pca$x[, 1:2], path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  4, acoustic.space = pca$x[, 1:2], path = tempdir())
centroids[-1] == centroids[1]
source("~/Dropbox/R_package_testing/ohun/R/get_templates.R")
FUN <- "get_templates"
#run function
source(file.path("./R", paste0(FUN,".R")))
# setwd(tempdir())
#open in rstudio
##open.fun(fun = FUN)
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
#remove images and sound files
rm.sf.img()
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
data("lbh_reference")
list.files(tempdir(), pattern = ".wav")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
# with custom acoustic space
spectral_parameters <- spectro_analysis(lbh_reference, path = tempdir())
# remove columns with NAs
spectral_parameters <- spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <- stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
template <- get_templates(reference = lbh_reference, n.sub.spaces =  4, acoustic.space = pca$x[, 1:2], path = tempdir())
FUN <- "get_templates"
#run function
source(file.path("./R", paste0(FUN,".R")))
# setwd(tempdir())
#open in rstudio
##open.fun(fun = FUN)
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
#remove images and sound files
rm.sf.img()
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
data("lbh_reference")
list.files(tempdir(), pattern = ".wav")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
# with custom acoustic space
spectral_parameters <- spectro_analysis(lbh_reference, path = tempdir())
# remove columns with NAs
spectral_parameters <- spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <- stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
template <- get_templates(reference = lbh_reference, n.sub.spaces =  4, acoustic.space = pca$x[, 1:2], path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  4, acoustic.space = pca$x[, 1:2], path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  2, acoustic.space = pca$x[, 1:2], path = tempdir())
source("~/Dropbox/R_package_testing/ohun/R/get_templates.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  2, acoustic.space = pca$x[, 1:2], path = tempdir())
template
template$template
source("~/Dropbox/R_package_testing/ohun/R/get_templates.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
# with custom acoustic space
spectral_parameters <- spectro_analysis(lbh_reference, path = tempdir())
# remove columns with NAs
spectral_parameters <- spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <- stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
template <- get_templates(reference = lbh_reference, n.sub.spaces =  2, acoustic.space = pca$x[, 1:2], path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, acoustic.space = pca$x[, 1:2], path = tempdir())
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
#built site
pkgdown::build_site(lazy = TRUE, preview = TRUE, examples = FALSE)
pkgdown::build_articles()
