} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#bid data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
#write all wav files in lbh_selec_table
write.sound.files <- function(path = tempdir(), extensible = T, other.formats = FALSE, selection.table = FALSE){
# setwd(path)
data(lbh_selec_table, package = "warbleR")
tuneR::writeWave(NatureSounds::Phae.long2, file.path(tempdir(),  "Phae.long2.wav"), extensible = extensible) #save sound files
tuneR::writeWave(NatureSounds::Phae.long1, file.path(tempdir(), "Phae.long1.wav"), extensible = extensible)
tuneR::writeWave(NatureSounds::Phae.long3, file.path(tempdir(), "Phae.long3.wav"), extensible = extensible) #save sound files
tuneR::writeWave(NatureSounds::Phae.long4, file.path(tempdir(), "Phae.long4.wav"), extensible = extensible)
if (other.formats){
file.copy(from = system.file("extdata", "recording_20170716_230503.wac", package = "bioacoustics"), to = file.path(tempdir(), "recording_20170716_230503.wac"))
file.copy(from = "../Phae.long4.mp3", to = file.path(tempdir(),  "Phae.long4.mp3"))
file.copy(from = file.path(tempdir(), "Phae.long1.wav"), to = file.path(tempdir(), "Phae.long5.wav"))
wav2flac(file.path(tempdir(), "Phae.long5.wav"))
if (selection.table){
lbh_selec_table$sound.files <- as.character(lbh_selec_table$sound.files)
sub_tab <- lbh_selec_table[lbh_selec_table$sound.files %in% c("Phae.long1.wav", "Phae.long4.wav"), 1:7]
sub_tab$sound.files[sub_tab$sound.files == "Phae.long1.wav"] <- "Phae.long5.flac"
sub_tab$sound.files[sub_tab$sound.files == "Phae.long4.wav"] <- "Phae.long4.mp3"
# fix times
sub_tab$start[sub_tab$sound.files == "Phae.long4.mp3"] <- c(0.2085945, 1.5950019, 2.3057996)
sub_tab$end[sub_tab$sound.files == "Phae.long4.mp3"] <- c(0.3528653, 1.7287163, 2.4289576)
sub_tab <- rbind(sub_tab, data.frame(sound.files = "recording_20170716_230503.wac", channel = 1, selec = 1, start = 0.1, end = 0.3, bottom.freq = 2, top.freq = 10))
sub_tab <- rbind(sub_tab, lbh_selec_table[, 1:7])
sub_tab$format <-ifelse(grepl("flac$", sub_tab$sound.files), "flac", ifelse(grepl("mp3$", sub_tab$sound.files), "mp3", "wav"))
return(sub_tab)
} else return(NULL)
}
}
# run all warbleR fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R", path = "./R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
# run.all()
list.selection.table <- function(lbh_selec_table, path = tempdir())
{
crr.dr <- getwd()
on.exit(setwd(crr.dr))
if(!is.null(path)) setwd(path)
Xlist <- list()
Xlist$Xdf <- lbh_selec_table
Xlist$Xst <- selection_table(lbh_selec_table)
Xlist$Xest <- selection_table(lbh_selec_table, extended = T, confirm.extended = F)
lbh_selec_table$song <- as.numeric(lbh_selec_table$sound.files)
Xlist$Xestbs <- selection_table(X = lbh_selec_table, extended = T, by.song = "song", confirm.extended = F)
names(Xlist) <- c("DATA.FRAME", "SELECTION_TABLE", "EXTENDED_SELECTION_TABLE", "by.song.EXTENDED_SELECTION_TABLE")
return(Xlist)
}
bi_mats <- function(X, labels) {
# create empty matrix to store memebership matrix
mat <- matrix(nrow = ncol(X), ncol = ncol(X))
# add labels to row and col names
rownames(mat) <- colnames(mat) <- labels
# add 0 if same lek and 1 if else
out <- lapply(1:(length(labels) - 1), function(i){
sapply((i + 1):length(labels), function(j)
if (labels[i] == labels[j]) 0 else 1)
})
# add to mat
mat[lower.tri(mat)] <- unlist(out)
# retunr as distance matrix
return(as.dist(mat))
}
FUN <- "filter_detection"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# an extra one in detection (1 false positive)
label_detection(reference = lbh_selec_reference[-1, ], detection = lbh_selec_reference)
# duplicate 1 detection row (to get 2 splits)
label_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[c(1, 1:nrow(lbh_selec_reference)), ])
diagnose_detection(lbh_selec_reference[c(1, 1:nrow(lbh_selec_reference)), ])
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[c(1, 1:nrow(lbh_selec_reference)), ])
ld
# duplicate 1 detection row (to get 2 splits)
ld <- label_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[c(1, 1:nrow(lbh_selec_reference)), ])
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[c(1, 1:nrow(lbh_selec_reference)), ])
# duplicate 1 detection row (to get 2 splits)
split_detec <- lbh_selec_reference[c(1, 1:nrow(lbh_selec_reference)), ]
# EXAMPLES
# save wav file examples
write.sound.files()
list.files(tempdir(), ".wav")
# template for the first sound file in 'lbh_selec_reference'
templ1 <- lbh_selec_reference[1, ]
# generate template correlations
tc <- template_correlator(templates = templ1, path = tempdir(), files = "Phae.long1.wav")
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.4)
td
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.1)
td
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.2)
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.15)
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.12)
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.13)
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.1)
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.12)
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# this detection enerates 2 split positives
label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
filter_detection(td)
# this detection enerates 2 split positives
ltd <- label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# this detection enerates 2 split positives
(ltd <- label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td))
filter_detection(ltd)
# this detection enerates 2 split positives
diagnose_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
(ltd <- label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td))
diagnose_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = ftd)
# now they can be filter to keep the detection with the highest score for each split
ftd <- filter_detection(ltd)
diagnose_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = ftd)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
FUN <- "filter_detection"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
list.files(tempdir(), ".wav")
# template for the first sound file in 'lbh_selec_reference'
templ1 <- lbh_selec_reference[1, ]
# generate template correlations
tc <- template_correlator(templates = templ1, path = tempdir(), files = "Phae.long1.wav")
# template detection
td <- template_detector(template.correlations = tc, threshold = 0.12)
# this detection generates 2 split positives
diagnose_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td)
# label detection
(ltd <- label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td))
detection = td
reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ]
if (is_extended_selection_table(reference)) stop("This function cannot take extended selection tables ('reference' argument)")
#if reference is not a data frame
if (!any(is.data.frame(reference), is_selection_table(reference)))
stop("'reference' is not of a class 'data.frame' or 'selection_table'")
#if reference is not a data frame
if (!any(is.data.frame(detection), is_selection_table(detection)))
stop("'detection' is not of a class 'data.frame' or 'selection_table'")
#check if all columns are found in reference
if (any(!(c(
"sound.files", "selec", "start", "end"
) %in% colnames(reference))))
stop(paste(paste(
c("sound.files", "selec", "start", "end")[!(c("sound.files", "selec",
"start", "end") %in% colnames(reference))], collapse =
", "
), "column(s) not found in 'reference'"))
#check if all columns are found in detection
if (any(!(c(
"sound.files", "selec", "start", "end"
) %in% colnames(detection))))
stop(paste(paste(
c("sound.files", "selec", "start", "end")[!(c("sound.files", "selec",
"start", "end") %in% colnames(detection))], collapse =
", "
), "column(s) not found in 'detection'"))
#if there are NAs in start or end stop (reference)
if (any(is.na(c(reference$end, reference$start))))
stop("NAs found in start and/or end columns")
#if any start higher than end stop
if (any(reference$end - reference$start <= 0))
stop(paste(
"Start is higher than or equal to end in",
length(which(reference$end - reference$start <= 0)),
"case(s) in 'reference'"
))
# add row labels to reference to identify merged detections
reference$..row.id <- 1:nrow(reference)
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makeCluster(parallel) else
cl <- parallel
unique(detection$sound.files)
z <-  unique(detection$sound.files)
# get subset from detection for that sound file
sub_detec <- detection[detection$sound.files == z, ]
any(reference$sound.files == z)
# get subset from template for that sound file
sub_ref <- reference[reference$sound.files == z, ]
nrow(sub_detec)
# get index of reference signals to which each detection overlaps
true_positives_refer_row_id <- lapply(1:nrow(sub_detec), function(y){
# defined as any detection that overlaps with the template selections
sub_ref$..row.id[(sub_ref$start >= sub_detec$start[y] & sub_ref$start < sub_detec$end[y]) |
(sub_ref$end > sub_detec$start[y] & sub_ref$end <= sub_detec$end[y]) |
(sub_ref$start <= sub_detec$start[y] & sub_ref$end >= sub_detec$end[y]) |
(sub_ref$start >= sub_detec$start[y] & sub_ref$end  <= sub_detec$end[y])]
})
true_positives_refer_row_id
# conver to label
sub_detec$detection.class <- sapply(true_positives_refer_row_id, function(x){
# count how many times the reference selection overlapped (splits)
splits <- if (length(x) != 0)
max(table(unlist(true_positives_refer_row_id)[unlist(true_positives_refer_row_id) %in% x]))  else 0
if (length(x) == 0) detection_class <- "false.positive"
if (length(x) == 1 & splits == 1) detection_class <- "true.positive"
if (length(x) == 1 & splits > 1) detection_class <- "true.positive (split)"
if (length(x) > 1 & splits == 1) detection_class <- "true.positive (merged)"
if (length(x) > 1 & splits > 1) detection_class <- "true.positive (split/merged)"
return(detection_class)
})
sub_detec$detection.class
# add index of selection in reference
sub_detec$reference.row <- sapply(true_positives_refer_row_id, function(x){
if (length(x) == 0) NA else paste(x, collapse = "-")
})
sub_detec$reference.row
# add overlap percentage
sub_detec$overlap <- NA
grep("-", sub_detec$reference.row)
grepl("-", sub_detec$reference.row)
grepl("-", sub_detec$reference.row) & is.na(sub_detec$reference.row)
!grepl("-", sub_detec$reference.row) | !is.na(sub_detec$reference.row)
!grepl("-", sub_detec$reference.row) & !is.na(sub_detec$reference.row)
sub_detec$reference.row
true_positives_refer_row_id
which(!grepl("-", sub_detec$reference.row) & !is.na(sub_detec$reference.row))
x = 1
detection$start[x]
sub_detec$reference.row[x]
sub_ref$..row.id
sub_ref$end[sub_ref$..row.id == sub_detec$reference.row[x]]
min(sub_ref$end[sub_ref$..row.id == sub_detec$reference.row[x]] - sub_detec$start[x], sub_detec$end[x] - sub_ref$start[sub_ref$..row.id == sub_detec$reference.row[x]]) / (sub_ref$end[sub_ref$..row.id == sub_detec$reference.row[x]] - sub_ref$start[sub_ref$..row.id == sub_detec$reference.row[x]])
sub_ref$end[sub_ref$..row.id == sub_detec$reference.row[x]] - sub_detec$start[x]
sub_detec$end[x] - sub_ref$start[sub_ref$..row.id == sub_detec$reference.row[x]]
sub_ref$end[sub_ref$..row.id == sub_detec$reference.row[x]] - sub_ref$start[sub_ref$..row.id == sub_detec$reference.row[x]]
12/19
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
# label detection
(ltd <- label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td))
source("~/Dropbox/R_package_testing/ohun/R/filter_detection.R")
# label detection
(ltd <- label_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = td))
# now they can be filter to keep the detection with the highest score for each split
ftd <- filter_detection(ltd)
ftd
# splits must be 0
diagnose_detection(reference = lbh_selec_reference[lbh_selec_reference == "Phae.long1.wav", ], detection = ftd)
# double checking happens inside label_detection()
labeled_detection <- label_detection(reference = reference, detection = detection, parallel = parallel, pb = pb)
labeled_detection
# # add row labels to reference for getting false negatives
reference$..row.id <- 1:nrow(reference)
# duration of corresponding selection in reference
labeled_detection$reference.duration <- sapply(1:nrow(labeled_detection), function(x){
if (is.na(labeled_detection$reference.row[x])) NA  else
if (grepl("-", labeled_detection$reference.row[x]))  NA else
labeled_detection$end[x] - labeled_detection$start[x]
})
# look at detections matching 1 training selection at the time
performance_list <- lapply(unique(labeled_detection$sound.files), function(z){
# get subset for that sound file
sub_detec <- labeled_detection[labeled_detection$sound.files == z, ]
sub_ref <- reference[reference$sound.files == z, ]
# get row index in reference for detected signals
detected_reference_rows <- unlist(lapply(sub_detec$reference.row, function(x) unlist(strsplit(x, "-"))))
performance <- data.frame(
sound.files = z,
# true.positives = sum(grepl("true", sub_detec$detection.class)),
true.positives = length(na.omit(unique(detected_reference_rows))),
false.positives = sum(grepl("false", sub_detec$detection.class)),
false.negatives = sum(!sub_ref$..row.id %in% detected_reference_rows),
# split.positives = sum(grepl("split", sub_detec$detection.class)),
split.positives = length(unique(
unlist(lapply(sub_detec$reference.row[grepl("split)", sub_detec$detection.class)], function(x) unlist(strsplit(x, "-")))))),
merged.positives = sum(grepl("merge", sub_detec$detection.class)),
mean.duration.true.positives = mean((sub_detec$end - sub_detec$start)[grep("true", sub_detec$detection.class)]),
mean.duration.false.positives = mean((sub_detec$end - sub_detec$start)[grep("false", sub_detec$detection.class)]),
mean.duration.false.negatives = mean((sub_ref$end - sub_ref$start)[!sub_ref$..row.id %in% detected_reference_rows]),
proportional.duration.true.positives = mean(sub_detec$reference.duration, na.rm = TRUE) / mean((sub_ref$end - sub_ref$start)[sub_ref$..row.id %in% detected_reference_rows], na.rm = TRUE),
sensitivity = sum(!is.na(unique(detected_reference_rows))) / nrow(sub_ref),
specificity =  if (nrow(sub_detec) > 0) sum(!is.na(unique(detected_reference_rows))) / (nrow(sub_ref) + sum(grep("false", sub_detec$detection.class))) else 0,
stringsAsFactors = FALSE
)
# replace NaNs with NA
for(i in 1:ncol(performance))
if (is.nan(performance[, i])) performance[, i] <- NA
# fix values when no false positives or true positives
performance$false.positives[performance$false.positives < 0] <- 0
performance$mean.duration.false.positives[is.na(performance$mean.duration.false.positives) | performance$false.positives == 0] <- NA
performance$mean.duration.true.positives[is.na(performance$mean.duration.true.positives) | performance$true.positives == 0] <- NA
# make sensitvities higher than 1 (because of split positives) 1
performance$sensitivity[performance$sensitivity > 1] <- 1
return(performance)
})
# add diagnostics of files in reference but not in detection
if (any(!reference$sound.files %in% unique(labeled_detection$sound.files)))
sub_detec
mean(sub_detec$overlap)
mean(sub_detec$overlap, na.rm = TRUE)
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
FUN <- "diagnose_detection"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# perfect detection
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference, time.diagnostics = TRUE)
# missing one in detection
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[-1, ], time.diagnostics = TRUE)
source("~/Dropbox/R_package_testing/ohun/R/summarize_diagnostic.R")
# missing one in detection
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[-1, ], time.diagnostics = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
FUN <- "optimize_template_detector"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
#remove images and sound files
rm.sf()
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
list.files(tempdir(), ".wav")
# template for the fourth sound file in 'lbh_selec_reference'
templ <- lbh_selec_reference[11, ]
# generate template correlations
tc <- template_correlator(templates = templ, path = tempdir(), files = "Phae.long4.wav")
# using 2 threshold
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files == "Phae.long4.wav", ], threshold = c(0.2, 0.5, 0.9))
any(!is.na(sub_detec$overlap))
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
FUN <- "optimize_template_detector"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
#remove images and sound files
rm.sf()
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
list.files(tempdir(), ".wav")
# template for the fourth sound file in 'lbh_selec_reference'
templ <- lbh_selec_reference[11, ]
# generate template correlations
tc <- template_correlator(templates = templ, path = tempdir(), files = "Phae.long4.wav")
# using 2 threshold
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files == "Phae.long4.wav", ], threshold = c(0.2, 0.5, 0.9))
# using 2 threshold
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files == "Phae.long4.wav", ], threshold = c(0.1, 0.5, 0.9))
# using 2 threshold
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files == "Phae.long4.wav", ], threshold = c(0.01, 0.5, 0.9))
# using several threshold
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files == "Phae.long4.wav", ], threshold = seq(0.5, 0.9, by = 0.05))
# template for the second and third sound file in 'lbh_selec_reference'
templ <- lbh_selec_reference[c(4, 7), ]
# generate template correlations
tc <- template_correlator(templates = templ, path = tempdir(), files = c("Phae.long2.wav", "Phae.long3.wav"))
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files %in% c("Phae.long2.wav", "Phae.long3.wav"), ], threshold = seq(0.3, 0.7, by = 0.1))
### showing diagnostics by sound file
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files %in% c("Phae.long2.wav", "Phae.long3.wav"), ], threshold = seq(0.5, 0.7, by = 0.1), by.sound.file = TRUE)
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
optimize_template_detector(template.correlations = tc, reference = lbh_selec_reference[lbh_selec_reference$sound.files %in% c("Phae.long2.wav", "Phae.long3.wav"), ], threshold = seq(0.3, 0.7, by = 0.1))
FUN <- "diagnose_detection"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# perfect detection
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference, time.diagnostics = TRUE)
# missing one in detection
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[-1, ], time.diagnostics = TRUE)
# an extra one in detection
diagnose_detection(reference = lbh_selec_reference[-1, ], detection = lbh_selec_reference, time.diagnostics = TRUE)
# and extra sound file in reference
diagnose_detection(reference = lbh_selec_reference, detection = lbh_selec_reference[lbh_selec_reference$sound.files != "Phae.long1.wav", ], time.diagnostics = TRUE)
# and extra sound file in detection
diagnose_detection(reference = lbh_selec_reference[lbh_selec_reference$sound.files != "Phae.long1.wav", ], detection = lbh_selec_reference, time.diagnostics = TRUE)
# and extra sound file in detection by sound file
dd <- diagnose_detection(reference = lbh_selec_reference[lbh_selec_reference$sound.files != "Phae.long1.wav", ], detection = lbh_selec_reference, time.diagnostics = TRUE, by.sound.file = TRUE)
# get summary
summarize_diagnostic(dd)
# merged detection
lbh_selec2 <- lbh_selec_reference
lbh_selec2$end[11] <- 1
lbh_selec2$end[12] <- 1
diagnose_detection(reference = lbh_selec2, detection = lbh_selec_reference, time.diagnostics = FALSE, by.sound.file = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
#built site
pkgdown::build_site(lazy = TRUE, preview = TRUE, examples = FALSE)
# only non-ambiguous true positives
sub_detec$overlap[!grepl("-", sub_detec$reference.row) & !is.na(sub_detec$reference.row)] <- sapply(which(!grepl("-", sub_detec$reference.row) & !is.na(sub_detec$reference.row)), function(x){
min(sub_ref$end[sub_ref$..row.id == sub_detec$reference.row[x]] - sub_detec$start[x], sub_detec$end[x] - sub_ref$start[sub_ref$..row.id == sub_detec$reference.row[x]]) / (sub_ref$end[sub_ref$..row.id == sub_detec$reference.row[x]] - sub_ref$start[sub_ref$..row.id == sub_detec$reference.row[x]])
})
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
