---
title: <center><font size="7"><b><i>ohun</i>&#x3A; Automatic detection of acoustic signals</b></font></center>
pagetitle: Introduction to warbleR
author: 
- <center><a href="https://marceloarayasalas.weebly.com">Marcelo Araya-Salas, PhD</a></center>
date:  <center>"`r Sys.Date()`"</center>
output:
  rmarkdown::html_document:
    self_contained: yes
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: true
vignette: >
   %\VignetteIndexEntry{1. Introduction to ohun}
   %\usepackage[utf8]{inputenc}
   %\VignetteEncoding{UTF-8}
   %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

<!-- <script> -->
<!--    $(document).ready(function() { -->
<!--      $head = $('#header'); -->
<!--      $head.prepend('<img src=\"logo.png\"/>') -->
<!--    }); -->
<!-- </script> -->

<!-- &nbsp;  -->

&nbsp; 

[ohun](https://github.com/maRce10/ohun) is intended to facilitate the automatic detection of acoustic signals, providing functions to diagnose and optimize detection routines. Detections from other software can also be explored and optimized.

&nbsp; 

<div class="alert alert-info">

<font size = "4">The main features of the package are: </font>

- The use of reference annotations for detection optimization and diagnostic 
- The use of signal detection theory diagnostic parameters to evaluate detection performance 
- The batch processing of sound files for improving computational performance

&nbsp;

<font size = "4">The package offers functions for: </font>

- Energy-based detection
- Template-based detection
- Diagnose detection precision
- Optimize detection routines based on reference annotations

</div>



All functions allow the parallelization of tasks, which distributes the tasks among several processors to improve computational efficiency. The package works on sound files in '.wav', '.mp3', '.flac' and '.wac' format.

--- 

To install the latest developmental version from [github](https://github.com/) you will need the R package [devtools](https://cran.r-project.org/package=devtools):


```{r, eval = FALSE}

# install pacakge
devtools::install_github("maRce10/ohun")

#load package
library(ohun)

```

```{r global options, echo = FALSE, message=FALSE, warning=FALSE}

#load package
library(ohun)

# for spectrograms
par(mar = c(5, 4, 2, 2) + 0.1)

# align figures
opts_chunk$set(fig.align='center') 
```

&nbsp;


---

## Energy-based detection

It uses amplitude envelopes to infer the position of signals. These detectors don't require highly stereotyped signals, although they work better on high quality recordings in which the amplitude of target signals is higher than the background noise (i.e. high signal-to-noise ratio). The function `ernergy_detector()` performs this type of detection. The syntax `package.name::function.name()` will be used here and throughout the vignette to highlight functions coming from packages other than [ohun](https://github.com/maRce10/ohun),

&nbsp;

### How it works 

We can understand how to use `ernergy_detector()` using simulating animal signals. We will do that using the function `simulate_songs()` from [warbleR](https://CRAN.R-project.org/package=warbleR). In this example we simulate a recording with 10 sounds with 2 different frequency ranges and durations:

```{r}

# install this package first if not available
# install.packages(" Sim.DiffProc")

#Creating vector for duration 
durs <- rep(c(0.5, 1), 5)

#Creating simulated song
set.seed(10)
ss1 <- warbleR::simulate_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, selec.table = TRUE, file.name = "ss1", harms = 1, bgn = 0.1, path = tempdir())

```
&nbsp;

This is how the simulated recording looks like:

```{r, fig.height=4}

# plot spectrogram
seewave::spectro(ss1$wave, osc = FALSE, scale = FALSE, collevels = seq(-45, 0, 5), fastdisp = TRUE, flim = c(0, 10), grid = FALSE)

```
&nbsp;

The signals in that recording can be detected using `ernergy_detector()` as follows:

```{r, fig.height=4}

#Detecting all elements
sim_ad <- energy_detector(files = ss1$selec.table$sound.files[1], bp = c(1, 8), ssmooth = 10, threshold = 0.5, min.duration = 0.001, path = tempdir(), pb = FALSE)

# plot spectro
seewave::spectro(ss1$wave, osc = FALSE, scale = FALSE, collevels = seq(-45, 0, 5), fastdisp = TRUE, flim = c(0, 10))

# plot detections
for(e in 1:nrow(sim_ad))
 polygon(x = rep(c(sim_ad$start[e], sim_ad$end[e]), 
                  each = 2), y = c(0, 10, 10, 0), lty = 2, border = "#07889B", 
                  col = adjustcolor("#07889B", alpha.f = 0.12), 
                  lwd = 1.2)

```
&nbsp;

Now we will make use of some additional arguments to filter out specific signals based on their structural features. For instance we can use the argument `minimum.duration` to exclude short signals and keep only the longest signals:

```{r eval = TRUE, echo = TRUE, fig.height=4}

#Detecting all elements
sim_ad <- energy_detector(files = ss1$selec.table$sound.files[1], bp = c(1, 8), ssmooth = 10, threshold = 0.5, min.duration = 0.6, path = tempdir(), pb = FALSE)

# plot spectrogram
seewave::spectro(ss1$wave, osc = FALSE, scale = FALSE, collevels = seq(-50, 0, 5), fastdisp = TRUE, flim = c(0, 10))

# plot detections
for(e in 1:nrow(sim_ad))
 polygon(x = rep(c(sim_ad$start[e], sim_ad$end[e]), 
                  each = 2), y = c(0, 10, 10, 0), lty = 2, border = "#07889B", 
                  col = adjustcolor("#07889B", alpha.f = 0.12), 
                  lwd = 1.2)
```
&nbsp;

We can use the argument `max.duration` to exclude long signals and keep the short signals:

```{r eval = TRUE, echo = TRUE, fig.height=4}

#Detecting all elements
sim_ad <- energy_detector(files = ss1$selec.table$sound.files[1], bp = c(1, 8), ssmooth = 10, threshold = 0.5, min.duration = 0.001, max.duration = 0.6, path = tempdir(), pb = FALSE)

# plot spectrogram
seewave::spectro(ss1$wave, osc = FALSE, scale = FALSE, main = Sys.time(), collevels = seq(-50, 0, 5), fastdisp = TRUE, flim = c(0, 10))

# plot detections
for(e in 1:nrow(sim_ad))
 polygon(x = rep(c(sim_ad$start[e], sim_ad$end[e]), 
                  each = 2), y = c(0, 10, 10, 0), lty = 2, border = "#07889B", 
                  col = adjustcolor("#07889B", alpha.f = 0.12), 
                  lwd = 1.2)

```
&nbsp;

We can also focus the detection on specific frequency ranges using the argument `bp` (bandpass). By setting `bp = c(5, 8)`we can detect those signals found within that frequency range (5-8 kHz), which excludes signals below 5 kHz:

```{r, fig.height=4, eval = TRUE, echo = TRUE}

#Detecting all elements
sim_ad <- energy_detector(files = ss1$selec.table$sound.files[1], bp = c(5, 8), ssmooth = 10, threshold = 0.5, min.duration = 0.0001, path = tempdir(), pb = FALSE)

# plot spectrogram
spectro(ss1$wave, osc = FALSE, scale = FALSE, main = Sys.time(), collevels = seq(-50, 0, 5), fastdisp = TRUE, flim = c(0, 10))

# plot detections
for(e in 1:nrow(sim_ad))
 polygon(x = rep(c(sim_ad$start[e], sim_ad$end[e]), 
                  each = 2), y = c(0, 10, 10, 0), lty = 2, border = "#07889B", 
                  col = adjustcolor("#07889B", alpha.f = 0.12), 
                  lwd = 1.2)

```


The same logic can be applied to  detect those signals found below 5 kHz. We just need to set `bp = (0, 6)`:

```{r, fig.height=4, eval = TRUE, echo = TRUE}

#Detecting all elements
sim_ad <- energy_detector(files = ss1$selec.table$sound.files[1], bp = c(0, 6), ssmooth = 10, threshold = 0.5, min.duration = 0.0001, path = tempdir(), pb = FALSE)

# plot spectrogram
spectro(ss1$wave, osc = FALSE, scale = FALSE, main = Sys.time(), collevels = seq(-50, 0, 5), fastdisp = TRUE, flim = c(0, 10))

# plot detections
for(e in 1:nrow(sim_ad))
 polygon(x = rep(c(sim_ad$start[e], sim_ad$end[e]), 
                  each = 2), y = c(0, 10, 10, 0), lty = 2, border = "#07889B", 
                  col = adjustcolor("#07889B", alpha.f = 0.12), 
                  lwd = 1.2)

```



Amplitude modulatio (variation in amplitude across a signal) can be problematic for detection based on amplitude envelopes. We can also simulate some amplitude modulation using `warbleR::simulate_songs()`:


```{r, fig.height=4, eval = FALSE}

#Creating simulated song
set.seed(10)
ss2 <- warbleR::simulate_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, selec.table = TRUE, file.name = "ss1", harms = 1, bgn = 0.1, path = tempdir(), steps = 10, am.amps = c(1, 2, 3, 2, 0.1, 2, 3, 3, 2, 1))

spectro(ss2$wave, osc = TRUE, scale = FALSE, collevels = seq(-50, 0, 5), fastdisp = TRUE, flim = c(0, 10), heights = c(2, 1))

```
&nbsp;

When signals have strong amplitude modulation they can be split during detection:

```{r, fig.height=4, eval = FALSE}

# detect sounds
sim_ad <- auto_detec(flist =  ss2$selec.table$sound.files[1], bp = c(1, 8), ssmooth = 400, threshold = 50, mindur = 0.001, path = tempdir())

spectro(ss2$wave, osc = TRUE, scale = FALSE, collevels = seq(-50, 0, 5), fastdisp = TRUE, flim = c(0, 10), heights = c(2, 1))

# plot detection
for(e in 1:nrow(sim_ad))
 polygon(x = rep(c(sim_ad$start[e], sim_ad$end[e]), 
                  each = 2), y = c(0, 10, 10, 0), lty = 2, border = "#07889B", 
                  col = adjustcolor("#07889B", alpha.f = 0.12), 
                  lwd = 1.2)

```

&nbsp;

- Use the argument `holdtime` to merge selections from the same signal

- Try increasing `ssmooth` to merge selections from the same signal (do not use `holdtime`)


&nbsp;


Please cite [ohun](https://github.com/maRce10/ohun)  as follows:

Araya-Salas, M. (2020), ohun: automatic detection of acoustic signals. R package version 0.1.0.


<font size = "20">UNDER DEVELOPMENT</font>

Observaciones:

avoid having overlapping selections in reference (check with overlapping_sels())

downsample to a freq range just enough for the signals of interest

use hop.size instead of wl

after split_sound_files() another function that returns the position in the original unsplit sound file

count number of detections per unit of time


## References

1. Araya-Salas, M. (2021), ohun: automatic detection of acoustic signals. R package version 0.1.0.
1. Araya-Salas M, Smith-Vidaurre G (2017) warbleR: An R package to streamline analysis of animal acoustic signals. Methods Ecol Evol 8:184-191.

&nbsp; 

---

<font size="4">Session information</font>

```{r session info, echo=F}

sessionInfo()

```


