% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_envelopes.R
\name{get_envelopes}
\alias{get_envelopes}
\title{Extract absolute amplitude envelopes}
\usage{
get_envelopes(path = NULL, files = NULL, bp = NULL, wl = 512, power = 1,
parallel = 1, thinning = 1, pb = TRUE, ssmooth = 0, normalize = TRUE,
filter = "ffilter")
}
\arguments{
\item{path}{Character string containing the directory path where the sound files are located.
If \code{NULL} (default) then the current working directory is used.}

\item{files}{character vector or indicating the sound files that will be analyzed.}

\item{bp}{Numeric vector of length 2 giving the lower and upper limits of a
frequency bandpass filter (in kHz). Default is \code{NULL}.}

\item{wl}{A numeric vector of length 1 specifying the window used internally
for bandpass filtering (so only applied when 'bp' is supplied). Default is 512.}

\item{power}{A numeric vector of length 1 indicating a power factor applied to the amplitude envelope. Increasing power will reduce low amplitude modulations and increase high amplitude modulations, in order to reduce background noise. Default is 1 (no change).}

\item{parallel}{Numeric. Controls whether parallel computing is applied.
It specifies the number of cores to be used. Default is 1 (i.e. no parallel computing).}

\item{thinning}{Numeric vector of length 1 in the range 0~1 indicating the proportional reduction of the number of
samples used to represent amplitude envelopes (i.e. the thinning of the envelopes). Usually amplitude envelopes have many more samples
than those needed to accurately represent amplitude variation in time, which affects the size of the
output (usually very large R objects / files). Default is \code{1} (no thinning). Higher sampling rates can afford higher size reduction (e.g. lower thinning values). Reduction is conducted by linear interpolation using \code{\link[stats]{approx}}. Note that thinning may decrease time precision and that the higher the thinning the less precise the time detection. It's generally not advised if no smoothing ('ssmooth' argument) is applied.}

\item{pb}{Logical argument to control progress bar. Default is \code{TRUE}.}

\item{ssmooth}{A numeric vector of length 1 to smooth the amplitude envelope
with a sum smooth function. Default is 0. Note that smoothing is applied before thinning (see 'thinning' argument).}

\item{normalize}{Logical argument to control if}

\item{filter}{Character vector of length 1 indicating the bandpass filter to be applied (only used if 'bp' is supplied). Three options available, (corresponding to the frequency filter functions in the 'seewave' package): ffilter (\code{\link[seewave]{ffilter}}), bwfilter (\code{\link[seewave]{bwfilter}}) and fir (\code{\link[seewave]{fir}}).}
}
\value{
An object of class 'envelopes'.
}
\description{
\code{get_envelopes} extracts absolute amplitude envelopes to speed up energy detection
}
\details{
This function determines the start and end of signals in the sound file selections listed
  in the input data frame ('X'). Alternatively, if no data frame is provided, the function detects signals across
  each entire sound file. It can also create long spectrograms highlighting the start and of the detected
  signals for all sound files in the working directory (if \code{img = TRUE}). Sound files should be located in the
   working directory or the path to the sound files should be provided using the 'path' argument. The input
   data frame should have the following columns: c("sound.files","selec","start","end"). This function uses a modified version of the \code{\link[seewave]{timer}} function from seewave package to detect signals.
}
\examples{
{
# Save to temporary working directory
data(list = c("Phae.long1", "Phae.long2"))
writeWave(Phae.long1, file.path(tempdir(), "Phae.long1.wav"))
writeWave(Phae.long2, file.path(tempdir(), "Phae.long2.wav"))

# get raw absolute amplitude envelopes
envs <- get_envelopes(path = tempdir())

# extract segment for the first signal in the first sound file
x <- envs[[1]]$envelope

# and plot it
plot(x[(length(x)/9):(length(x)/4)], type = "l", xlab = "samples", ylab = "amplitude")

# smoothing envelopes
envs <- get_envelopes(path = tempdir(), ssmooth = 300)
x <- envs[[1]]$envelope
plot(x[(length(x)/9):(length(x)/4)], type = "l", xlab = "samples", ylab = "amplitude")

# smoothing and thinning
envs <- get_envelopes(path = tempdir(), thinning = 1/10, ssmooth = 300)
x <- envs[[1]]$envelope
plot(x[(length(x)/9):(length(x)/4)], type = "l", xlab = "samples", ylab = "amplitude")

# no normalization
envs <- get_envelopes(path = tempdir(), thinning = 1/10, ssmooth = 300)
x <- envs[[1]]$envelope
plot(x[(length(x)/9):(length(x)/4)], type = "l", xlab = "samples", ylab = "amplitude",
normalize = FALSE)
}

}
\references{
{
Araya-Salas, M., & Smith-Vidaurre, G. (2017). warbleR: An R package to streamline analysis of animal acoustic signals. Methods in Ecology and Evolution, 8(2), 184-191.
}
}
\seealso{
\code{\link{energy_detector}}
}
\author{
Marcelo Araya-Salas (\email{marcelo.araya@ucr.ac.cr}). Implements a
modified version of the timer function from seewave.
}
